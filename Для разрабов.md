## Для начала, лирика
Данный декомпилятор Java не всегда может корректно декомпилировать код. При этом, я придерживаюсь принципа,
что лучше криво декомпилированный код, чем падение с ошибкой, то есть декомпилятор выведет код всегда, когда сможет это сделать.
Он не отвечает за проверку того, что переменные всегда инициализированы, все части кода достижимы и для всех **new**
вызывается конструктор. Всё вышеперечисленное - работа компилятора.

## Основные классы

### Сущности
- **DecompilingClass**, **DecompilingField** и **DecompilingMethod** - классы, поля и методы, 
которые читает и декомпилирует наше приложение.

- **Instruction** - инструкция, хранит опкод и операнды. Не хранит ссылки на другие инструкции.
- **FlowControlInsn** - инструкция, которая может изменить поток выполнения байткода.
К таким относятся инструкции условного и безусловного перехода, **return** и **throw**.

- **Operation** - операция, в отличие от инструкции может ссылаться на другие операции.

- **Scope** - область видимости, ограниченная фигурными скобками, в т.ч. условия, циклы и т.д. Наследуется от **Operation**.
*Важно:* область видимости класса не является **Scope**-ом.

- **MethodScope** - область видимости всего метода. Наследуется от **Scope**.


- **Chunk** - фрагмент байткода, выполняющийся непрерывно от начала до конца.
Переход на середину чанка должен быть невозможен, иначе его нужно разделить на два чанка.
Каждый чанк содержит список инструкций и, возможно, одну **FlowControlInsn** в конце.


- **Type** - тип чего-либо. Самые основные - **PrimitiveType**, **ClassType** и **ArrayType**.

- **VariableReference** - ссылка на переменную, используется, когда сами переменные ещё не восстановлены.
Несколько ссылок могут указывать на одну и ту же переменную.

- **Variable** - переменная. Содержит номер слота, тип и имя.

- **FieldDescriptor**, **MethodDescriptor** - дескрипторы поля и метода.
- **IncompleteMethodDescriptor** - дескриптор метода без класса, в котором этот метод объявлен.


### Служебные классы
- **Context** - контекст декомпиляции, предоставляет доступ к свойствам текущего класса,
а также остальным классам, полям и методам.

- **MethodContext** - контекст метода, предоставляет доступ к данным текущего метода. Наследуется от **Context**.

- **CodeGraph** - хранит весь код метода и проводит его декомпиляцию. Находится внутри **MethodContext**.
Может быть **null**, если метод не имеет тела или если при декомпиляции произошло **DecompilationException**.


## Система переменных
В байткоде доступ к переменным осуществляется по её слоту, при этом переменные типа **long** и **double**
занимают два слота. Доступ к **this** осуществляется через переменную с нулевым слотом. Таким образом,
слот переменной не всегда соответствует индексу аргумента в его дескрипторе.


Сначала при декомпиляции используются только экземпляры **VariableReference**. Алгоритм восстановления переменных
пока что переписывается из-за многочисленных багов (старый алгоритм хорош, но недоработан).


Идея простая: каждая операция каким-либо образом использует переменную из конкретного слота.
Это описывается классом **enum VarUsage**:
- **NONE** - никак не использует.
- **LOAD** - читает переменную (она должна быть объявлена и инициализирована перед использованием).
- **STORE** - сохраняет значение в переменную (она может быть объявлена при сохранении или раньше него).
- **MAYBE_STORE** - сохраняет значение в переменную, но не всегда (например, если сохранение происходит в теле **if**).


Выражения типа `i += 1` считаются **LOAD**, потому что переменная *сначала* читается, и только *потом* записывается.

Значение **MAYBE_LOAD** эквивалентно **LOAD**, так как даже если переменная не 100% будет использоваться,
она всё равно должна быть объявлена и инициализирована.

Каждый **STORE** сбрасывает предыдущую переменную и создаёт новую, так как какая разница, будет ли существовать
старая переменная, если в неё сохраняется новое значение, не зависящее от старого.

Каждый **LOAD** должен идти после соответствующего **STORE** (есть сложные случаи, например **if-else**, которые
всегда инициализируют переменную, они должны быть рассмотрены отдельно).

Если внешний **Scope** использует ту же переменную, что и вложенный, то право собственности переходит внешнему (хехехеха).


### Правила вычисления VarUsage для if:
- **if** возвращает **STORE**, если:
	- У него есть **else**.
	- Как **if**, так и **else** гарантированно инициализируют переменную или завершаются выходом из функции (**return**/**throw**).
- **if** возвращает то, что вернул его заголовок, если это значение не **NONE**.
- **if** возвращает **MAYBE_STORE**, если его тело вернуло **STORE**.


## Стек
Если операция возвращает не **void**, то она кладётся на стек. Для каждого чанка стек эмулируется отдельно,
таким образом у чанка есть списки операций, которые он принимает и возвращает. Затем эти операции связываются
друг с другом. Это необходимо для правильной декомпиляции тернарных операторов и **switch**-выражений.


## Порядок декомпиляции
- Создание экземпляров **DecompilingClass**, **DecompilingField** и **DecompilingMethod** с использованием соответствующих **visitor**-ов.
- Вызов метода **DecompilingClass.initNested**, где происходит связывание внешних и вложенных классов.
- Вызов метода **decompile**:
	- Создание карты чанков.
	- Создание **MethodContext**.
	- Преобразование списка инструкций в дерево операций внутри каждого чанка.
	- Поиск границ для всех **scope**-ов и их создание.
	- Преобразование списка **scope**-ов в иерархию, добавление операций в эту иерархию.
	- Связывание состояний стека между чанками.
	- Рекурсивный вызов метода **Scope.postDecompilation**. На этом этапе происходит удаление большинства
	  ненужных операций, определение инициализаторов полей, а также полей, которые являются ссылками на
	  внешние переменные для вложенных классов.

- После декомпиляции *всех* методов вызывается **Scope.afterDecompilation**. На этом этапе:
	- Некоторые пары операций объединяются в одну, если метод **Operation.canUnite** для них вернёт **true**.
	- Добавляется аннотация `@Override`.

- Затем **DecompilingClass.processVariables**:
	- Рекурсивный метод **Operation.beforeVariablesInit**, в котором происходит связывание
	  с внешними переменными во вложенных классах и лямбдах.
	  
	- Метод **DecompilingField.beforeVariablesInit**, так как операция инициализации поля удаляется из метода,
	  и для неё необходимо отдельно вызывать метод.
	  
	- Рекурсивный метод **MethodScope.initVariables** в определённом порядке, что необходимо
	  для правильной инициализации переменных в лямбда-выражениях
	
	- Рекурсивный метод **MethodScope.inferVariableTypesAndNames** (в том же порядке):
		- **Operation.inferType** (два раза для корректного вывода типов).		
		- **Operation.declareVariables**
		- **Operation.initPossibleVarNames**
		- **Operation.initVariableNames**
	
	- Метод **DecompilingField.inferVariableTypes** выводит типы переменных.

- **DecompilingClass.addImports** добавляет все импорты.
- **DecompilingClass.computeImports** решает, что нужно импортировать, а что - нет.
- Рекурсивный вызов **write**.
